# -*- coding: utf-8 -*-
"""Multi-level_Queue_Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10Twbj8KPzeuzpibj17hRjVuNhuvCbYgy
"""

class Process:
    def __init__(self, pid, arrival_time, burst_time, priority):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.remaining_time = burst_time
        self.priority = priority
        self.start_time = 0
        self.end_time = 0
        self.response_time = -1
        self.waiting_time = 0
        self.turnaround_time = 0

    def execute(self, time_slice):
        if self.remaining_time <= time_slice:
            time_slice = self.remaining_time
            self.end_time = self.start_time + time_slice
            self.remaining_time = 0
        else:
            self.remaining_time -= time_slice
            self.end_time = self.start_time + time_slice

        return time_slice


class MLFQ:
    def __init__(self, num_queues, quantum_times, aging_time):
        self.num_queues = num_queues
        self.quantum_times = quantum_times
        self.aging_time = aging_time
        self.queues = [[] for _ in range(num_queues)]
        self.time = 0
        self.processes = []

    def add_process(self, process):
        self.processes.append(process)
        self.queues[0].append(process)

    def schedule(self):
        gantt_chart = []
        done = []
        for i in range(self.num_queues):
            for process in self.queues[i]:
                if process.response_time == -1:
                    process.response_time = self.time - process.arrival_time
                if process.execute(self.quantum_times[i]) == 0:
                    done.append(process)
                else:
                    if self.time - process.start_time >= self.aging_time and i != self.num_queues - 1:
                        self.queues[i].remove(process)
                        self.queues[i+1].append(process)
                gantt_chart.append(process.pid)
            self.time += self.quantum_times[i]
        for process in done:
            process.waiting_time = process.end_time - process.arrival_time - process.burst_time
            process.turnaround_time = process.end_time - process.arrival_time
        return gantt_chart

    def run(self):
        gantt_chart = self.schedule()
        print("Gantt Chart: ", gantt_chart)
        print("Process Details:")
        print("PID\tArrival Time\tBurst Time\tResponse Time\tWaiting Time\tTurnaround Time")
        for process in self.processes:
            print(f"{process.pid}\t{process.arrival_time}\t\t{process.burst_time}\t\t{process.response_time}\t\t{process.waiting_time}\t\t{process.turnaround_time}")


if __name__ == "__main__":
    num_queues = int(input("Enter the number of queues: "))
    quantum_times = [int(input(f"Enter the quantum time for queue {i+1}: ")) for i in range(num_queues)]
    aging_time = int(input("Enter the aging time: "))
    num_processes = int(input("Enter the number of processes: "))
    processes = []
    for i in range(num_processes):
        pid = int(input(f"Enter the process ID for process {i+1}: "))
        arrival_time = int(input(f"Enter the arrival time for process {i+1}: "))
        burst_time = int(input(f"Enter the burst time for process {i+1}: "))
        priority = int(input(f"Enter the priority for process {i+1}: "))
        processes.append(Process(pid, arrival_time, burst_time, priority))

mlfq = MLFQ(num_queues, quantum_times, aging_time)

# Add the processes to the MLFQ
for process in processes:
    mlfq.add_process(process)

# Run the simulation
mlfq.run()