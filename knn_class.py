# -*- coding: utf-8 -*-
"""KNN_class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JnkSEb3amEvIB_P9FAvg5s_S3-XosKJf
"""

from google.colab import drive
drive.mount('/content/drive')

from numpy import genfromtxt
data_path='/content/drive/MyDrive/Colab Notebooks/iris.csv'
my_data=genfromtxt(data_path,delimiter=',')

type(my_data)

import random as r
import numpy as np
train_set=[]
val_set=[]
test_set=[]
r.shuffle(my_data)
#print(my_data)
r.seed()
for s in range(len(my_data)):
  R=r.uniform(0,1)
  if R >= 0  and R<= .7:
      train_set.append(my_data[s])
  elif R >0.7  and R <= 0.85:
    val_set.append(my_data[s])
  else:
    test_set.append(my_data[s])
#print(train_set,val_set,test_set)

import random as r
import numpy as np
from math import sqrt

def findeldist(row1, row2):
    distance = 0.0
    for i in range(len(row1)-1):
        distance += (row1[i] - row2[i])**2
    return sqrt(distance)

def majority(test):
  foo=0
  poo=0
  value=0
  for i in test:
      foo=test.count(i)
      if foo>poo:
          poo=foo
          value =i
  return value

def knnclssification (k):
  countvs=0
  for v in val_set:
    L=[]
    for t in train_set:
      dist= findeldist(v,t)

      L.append((t[-1],dist))
    L.sort(key=lambda a: a[1])
    L=L[:k]

    p=[(L[i][0]) for i in range (0,k)]

    majcls=majority(p)

    if v[-1]==majcls:
     # print ("ok")
      countvs+=1

    else:
      #print("not ok")
      continue
  accuracy=(countvs/len(val_set))*100
  #print(accuracy)
  return accuracy
k=[1,3,5,7]
for i in k:
  print(f'{knnclssification(i)} is for {i} ')

